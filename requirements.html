<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>

<head>
<title>requirements</title>
</head>

<body>

<!-- This document was automatically generated with bibtex2html 1.99
     (see http://www.lri.fr/~filliatr/bibtex2html/),
     with the following command:
     bibtex2html -nokeys --sort-by-date --reverse-sort --nobibsource -s alpha -unicode -header "<h1>Publications of George Avrunin</h1><br><h2>Requirements</h2>" -footer "<a href=index.html><img alt=[Back] src=/icons/back.gif>   Back to George Avrunin's home page</a>" requirements.bib  -->


<h1>Publications of George Avrunin</h1><br><h2>Requirements</h2>

<p><a name="conboy13:modal_abstraction"></a>

Heather&nbsp;M. Conboy, George&nbsp;S. Avrunin, and Lori&nbsp;A. Clarke.
 Modal abstraction view of requirements for medical devices used in
  healthcare processes.
 In <em>SEHC '13: Proceedings of the 2013 ICSE Workshop on Software
  Engineering in Health Care</em>, pages 24&#x2013;27, San Francisco, May 2013.
[&nbsp;<a href="papers/conboy13-modal_abstraction.pdf">.pdf</a>&nbsp;]
<blockquote><font size="-1">
Medical device requirements often depend on the
                  healthcare processes in which the device is to be
                  used. Since such processes may be complex, critical
                  requirements may be specified inaccurately, or even
                  missed altogether. We are investigating an automated
                  requirement derivation approach that takes as input
                  a model of the healthcare process along with a model
                  of the device and tries to derive the requirements
                  for that device. Our initial experience with this
                  approach has shown that when the process and device
                  involve complex behaviors, the derived requirements
                  are also often complex and difficult to
                  understand. In this paper, we describe an approach
                  for creating a modal abstraction view of the derived
                  requirements that decomposes each requirement based
                  on it.
</font></blockquote>

</p>

<p><a name="conboy10:derivation_of_requirements"></a>

Heather&nbsp;M. Conboy, George&nbsp;S. Avrunin, and Lori&nbsp;A. Clarke.
 Process-based derivation of requirements for medical devices.
 In <em>1st ACM International Health Informatics Symposium</em>, pages
  656&#x2013;665, Arlington, VA, November 2010.
[&nbsp;<a href="http://dx.doi.org/10.1145/1882992.1883095">DOI</a>&nbsp;| 
<a href="papers/conboy10-derivation_of_requirements.pdf">.pdf</a>&nbsp;]
<blockquote><font size="-1">
One goal of medical device certification is to show
                  that a given  medical device satisfies its
                  requirements. But the requirements that should be
                  met by such a device depend on the clinical
                  processes in which the device is to be used, and
                  such processes are increasingly large and
                  complex. Critical requirements may thus be specified
                  inaccurately or incompletely, or even missed
                  altogether, and the use of the devices may lead to
                  harm. Thus, we investigated a process-based
                  requirement derivation approach that inputs a model
                  that captures a particular medical process and a
                  requirement that should be satisfied by that
                  process, and outputs a derived requirement of the
                  medical device that is sufficient to prevent any
                  violations of the process requirement. Our approach
                  combines an approach for generating assumptions for
                  assume-guarantee reasoning with one for interface
                  synthesis to automate the derivation of the medical
                  device requirements. The proposed approach
                  iteratively performs the requirement derivation by
                  employing a model checker and a learning
                  algorithm. We implemented this approach and
                  evaluated our approach by applying it to two small
                  case studies. Our experiences showed that the
                  proposed approach could be successfully applied to
                  abstract models of portions of real medical
                  processes and that the derived requirements of the
                  medical devices appeared useful and understandable.
</font></blockquote>

</p>

<p><a name="phan08:considering_exceptional"></a>

Huong Phan, George&nbsp;S. Avrunin, and Lori&nbsp;A. Clarke.
 Considering the exceptional: Incorporating exceptions into property
  specifications.
 Technical Report UM-CS-2008-32, Department of Computer Science,
  University of Massachusetts, September 2008.
[&nbsp;<a href="http://laser.cs.umass.edu/techreports/08-32.pdf">.pdf</a>&nbsp;]
<blockquote><font size="-1">
Property specifications concisely describe aspects
                  of what a system is supposed to do. It is important
                  that these specifications be correct, describing all
                  the desired behavior and ruling out undesired
                  behavior. Our experience shows that properties are
                  sometimes specified incorrectly because specifiers
                  fail to take into account some exceptional behaviors
                  of the system. In previous work we presented
                  Propel, a tool that guides specifiers
                  through the process of creating understandable yet
                  precise property specifications. Here we describe
                  extensions to Propel that allow  specifiers
                  of a property to indicate what exceptions should be
                  considered and what impact those exceptions should
                  have on the acceptability of system behavior.
                  Although the description is given in terms of the
                  framework provided by Propel, the issues
                  specifiers must consider would apply to other
                  specification formalisms.
</font></blockquote>

</p>

<p><a name="cobleigh06:user_guidance"></a>

Rachel&nbsp;L. Cobleigh, George&nbsp;S. Avrunin, and Lori&nbsp;A. Clarke.
 User guidance for creating precise and accessible property
  specifications.
 In <em>Proceedings of the 14th ACM SIGSOFT Symposium on the
  Foundations of Software Engineering</em>, pages 208&#x2013;218, Portland, OR, November
  2006.
[&nbsp;<a href="http://dx.doi.org/10.1145/1181775.1181801">DOI</a>&nbsp;| 
<a href="papers/cobleigh06-user_guidance.pdf">.pdf</a>&nbsp;]
<blockquote><font size="-1">
Property specifications concisely describe what a
                  system is supposed to do. No matter what notation is
                  used to describe them, however, it is difficult to
                  represent these properties correctly, since there
                  are often subtle, but important, details that need
                  to be considered. Propel aims to guide
                  users through the process of creating properties
                  that are both accessible and mathematically precise,
                  by providing templates for commonly-occurring
                  property patterns. These templates explicitly
                  represent these subtle details as options. In this
                  paper, we present a new representation of these
                  templates, a Question Tree notation that asks users
                  a hierarchical sequence of questions about their
                  intended properties. The Question Tree notation is
                  particularly useful for helping to select the
                  appropriate template, but it also complements the
                  finite-state automaton and disciplined natural
                  language representations provided by
                  Propel. We also report on some case studies
                  that are using Propel and on an
                  experimental evaluation of the understandability of
                  the disciplined natural language representation
</font></blockquote>

</p>

<p><a name="chang06:property_inference"></a>

Richard&nbsp;M. Chang, George&nbsp;S. Avrunin, and Lori&nbsp;A. Clarke.
 Property inference from program executions.
 Technical report, Department of Computer Science, University of
  Massachusetts, 2006.
[&nbsp;<a href="papers/chang06-property_inference.pdf">.pdf</a>&nbsp;]
<blockquote><font size="-1">
Software verification techniques require properties
                  that define the intended behavior of a system be
                  specified. Generating such properties is often very
                  difficult and serves as an impediment to the
                  adoption of verification techniques. Techniques that
                  leverage program executions to infer these
                  properties are a promising avenue for automatically
                  generating these properties. In this paper, we
                  propose a property inference approach that leverages
                  event traces derived from program executions to
                  efficiently infer properties that are subtle
                  variations of commonly occurring properties. We
                  define <i>inference templates</i> that represent
                  sets of these properties and describe our inference
                  algorithm that refines these templates based on
                  event traces.
</font></blockquote>

</p>

<p><a name="smith03:monterey"></a>

Rachel&nbsp;L. Smith, George&nbsp;S. Avrunin, and Lori&nbsp;A. Clarke.
 From natural language requirements to rigorous property
  specifications.
 In <em>Workshop on Software Engineering for Embedded Systems (SEES
  2003): From Requirements to Implementation</em>, pages 40&#x2013;46, Chicago, IL,
  September 2003.
[&nbsp;<a href="papers/smith03-monterey.pdf">.pdf</a>&nbsp;]
<blockquote><font size="-1">
Property specifications concisely describe selected aspects of
	what a software system is supposed to do.  It is surprisingly
	difficult to write these properties correctly.  Although there
	are rigorous mathematical formalisms for representing
	properties, these are often difficult to use.  No matter what
	notation is used, however, there are often subtle, but
	important, details that need to be considered.  The Propel
	tool aims to make the job of writing and understanding
	properties easier by providing templates that explicitly
	capture these details as options for commonly-occurring
	property patterns.  These templates are represented using
	&ldquo;disciplined&rdquo; natural language, decision trees, and
	finite-state automata, allowing the developer to easily move
	between these representations.
</font></blockquote>

</p>

<p><a name="smith02:icse-propel"></a>

Rachel&nbsp;L. Smith, George&nbsp;S. Avrunin, Lori&nbsp;A. Clarke, and Leon&nbsp;J. Osterweil.
 Propel: An approach supporting property elucidation.
 In <em>Proceedings of the Twenty-Fourth International Conference on
  Software Engineering</em>, pages 11&#x2013;21, Orlando, FL, May 2002.
[&nbsp;<a href="http://dx.doi.org/10.1145/581339.581345">DOI</a>&nbsp;| 
<a href="papers/smith02-icse-propel.pdf">.pdf</a>&nbsp;]
<blockquote><font size="-1">
Property specifications concisely describe what a
                  software system is supposed to do.  It is
                  surprisingly difficult to write these properties
                  correctly.  There are rigorous mathematical
                  formalisms for representing properties, but these
                  are often difficult to use.  No matter what notation
                  is used, however, there are often subtle, but
                  important, details that need to be considered.
                  Propel aims to make the job of writing and
                  understanding properties easier by providing
                  templates that explicitly capture these details as
                  options for commonly-occurring property patterns.
                  These templates are represented using both
                  "disciplined" natural language and finite-state
                  automata, allowing the specifier to easily move
                  between these two representations.
</font></blockquote>

</p>

<p><a name="dwyer99:icse-patterns"></a>

Matthew&nbsp;B. Dwyer, George&nbsp;S. Avrunin, and James&nbsp;C. Corbett.
 Patterns in property specifications for finite-state verification.
 In <em>Proceedings of the Twenty-First International Conference on
  Software Engineering</em>, pages 411&#x2013;420, Los Angeles, May 1999.
[&nbsp;<a href="http://dx.doi.org/10.1145/302405.302672">DOI</a>&nbsp;| 
<a href="papers/dwyer99-icse-patterns.pdf">.pdf</a>&nbsp;]
<blockquote><font size="-1">
Model checkers and other finite-state verification tools allow
developers to detect certain kinds of errors automatically.
Nevertheless, the transition of this technology from research to
practice has been slow.  While there are a number of potential causes
for reluctance to adopt such formal methods, we believe that a
primary cause is that practitioners are unfamiliar
with specification processes, notations, and strategies.  In a recent
paper, we proposed a pattern-based approach to the presentation,
codification and reuse of property specifications for finite-state
verification.  Since then, we have carried out a survey of available
specifications, collecting over 500 examples of property
specifications.  We found that most are instances of our proposed
patterns.  Furthermore, we have updated our pattern system to
accommodate new patterns and variations of existing patterns
encountered in this survey.  This paper reports the results of the
	survey and the current status of our pattern system.
</font></blockquote>

</p>

<p><a name="dwyer98:fmsp-patterns"></a>

Matthew&nbsp;B. Dwyer, George&nbsp;S. Avrunin, and James&nbsp;C. Corbett.
 Property specification patterns for finite-state verification.
 In Mark Ardis, editor, <em>Proceedings of FMSP '98, the Second
  Workshop on Formal Methods in Software Practice</em>, pages 7&#x2013;15, Clearwater
  Beach, FL, March 1998.
[&nbsp;<a href="http://dx.doi.org/10.1145/298595.298598">DOI</a>&nbsp;| 
<a href="papers/dwyer98-fmsp-patterns.pdf">.pdf</a>&nbsp;]
<blockquote><font size="-1">
Finite-state verification (e.g., model checking)
                  provides a powerful means to detect errors that are
                  often subtle and difficult to reproduce.
                  Nevertheless, the transition of this technology from
                  research to practice has been slow.  While there are
                  a number of potential causes for reluctance in
                  adopting such formal methods in practice, we believe
                  that a primary cause rests with the fact that
                  practitioners are unfamiliar with specification
                  processes, notations, and strategies.  Recent years
                  have seen growing success in leveraging experience
                  with design and coding patterns.  We propose a
                  pattern-based approach to the presentation,
                  codification and reuse of property
                  specifications for finite-state verification.
</font></blockquote>

</p><hr><p><em>This file was generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.99.</em></p>
<a href=index.html><img alt=[Back] src=/icons/back.gif>   Back to George Avrunin's home page</a></body>
</html>
